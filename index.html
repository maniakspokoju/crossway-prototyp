za długie wspólne trasy 20.20 8:20

<!DOCTYPE html>
<html lang="pl">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no">

<title>Crossway Multi-user</title>
<link rel="stylesheet" href="https://unpkg.com/leaflet/dist/leaflet.css"/>
<style>
body {
    font-family: sans-serif;
    margin: 0;
    transition: background-color 0.3s ease;
    height: 100vh;
    display: flex;
    flex-direction: column;
}

/* ROLE BAR */
#roleBar {
  display: flex;
  width: 100%;
}
#roleBar button {
  width: 50%;
  height: 80px;
  font-size: 28px;
  border-radius: 0;
  cursor: pointer;
}
#driverBtn { background-color: #2f6fff; color: white; }
#passengerBtn { background-color: #2fbf6f; color: white; }

/* PANEL UŻYTKOWNIKA */
#driverDestinationDiv, #passengerControls {
  display: none;
  padding: 10px;
}
#driverDestinationDiv button, #passengerControls button {
  font-size: 24px;
  padding: 12px;
  margin: 5px 0;
  border-radius: 12px;
  cursor: pointer;
}
#driverDestinationDiv button:active, #passengerControls button:active {
  transform: scale(0.97);
}

/* MAPA */
#map {
  flex: 1;
}
</style>
</head>

<body>

									<h1 style="margin:5px 10px;">Crossway – 6.0.1</h1>

<div id="roleBar">
  <button id="driverBtn">Driver</button>
  <button id="passengerBtn">Passenger</button>
</div>

<div id="driverDestinationDiv">
  <button id="saveDriverDestinationBtn">Edytuj cel</button>
</div>

<div id="passengerControls">
  <div style="display:flex; gap:10px; margin-bottom:10px;">
    <button id="modeBtn" style="flex:5;">Tryb A</button>
    <button id="acceptBtn" style="flex:8; background:#ff5722; color:white;">Akceptuj trasę</button>
  </div>
  <div style="display:flex; gap:10px;">
    <button id="saveDestinationBtn" style="flex:1;">Edytuj cel</button>
    <button id="saveStartBtn" style="flex:1;">Edytuj start</button>
  </div>
</div>

<div id="driverBrowseControls" style="display:none; gap:10px; margin-top:10px;">
  <button id="prevDriverBtn" style="flex:1;">Cofnij</button>
  <button id="nextDriverBtn" style="flex:1;">Dalej</button>
</div>


<div id="map"></div>

<script src="https://www.gstatic.com/firebasejs/9.23.0/firebase-app-compat.js"></script>
<script src="https://www.gstatic.com/firebasejs/9.23.0/firebase-database-compat.js"></script>
<script src="https://unpkg.com/leaflet/dist/leaflet.js"></script>

<script>
/* ================= FIREBASE ================= */
firebase.initializeApp({
  apiKey: "AIzaSyBO8O-tNlduXs3VPr5UV8-A1MWesj1ptrc",
  databaseURL: "https://crossway-prototyp-default-rtdb.europe-west1.firebasedatabase.app/"
});
const db = firebase.database();

/* ================= GLOBAL ================= */
let currentUserId = null;
let currentRole = null;
let usersMarkers = {};
let selectedPoint = null;
let editingDestination = false;
let editingStart = false;
let currentMode = "A";
let acceptLocked = false;
// let matchingDrivers = [];
// let currentDriverIndex = 0;


// ===== Funkcja pobierająca kolejny numer użytkownika =====
async function getNextUserId() {
  const userCountRef = db.ref("session/userCount");
  const snapshot = await userCountRef.transaction(current => {
    return (current || 0) + 1; // jeśli brak, ustaw 1, inaczej zwiększ
  });
  return snapshot.snapshot.val(); // to będzie numer kolejnego użytkownika
}

/* ================= MAPA ================= */
const map = L.map("map").setView([52.1, 19.9], 12);
L.tileLayer("https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png").addTo(map);
const overlapLine = L.polyline([], { color: "red", weight: 7 }).addTo(map);

/* ================= UTILS ================= */
//const TOLERANCE_METERS = 160;
function distanceMeters(a,b){
  const R=6371000,dLat=(b[0]-a[0])*Math.PI/180,dLng=(b[1]-a[1])*Math.PI/180,x=dLng*Math.cos((a[0]+b[0])/2*Math.PI/180);
  return Math.sqrt(dLat*dLat+x*x)*R;
}
const TOLERANCE_METERS = 500; // większa tolerancja

function findClosestIndex(point, path){
  let min = Infinity, idx = -1;
  path.forEach((p, i) => {
    let pLat, pLng;
    if(Array.isArray(p)){
      [pLat, pLng] = p;
    } else {
      pLat = p.lat; pLng = p.lng;
    }
    const d = distanceMeters(point, [pLat, pLng]);
    if(d < min){ min = d; idx = i; }
  });
  // dodatkowy log dla debugowania
  // console.log("Closest distance:", min, "TOLERANCE_METERS:", TOLERANCE_METERS);
  return min <= TOLERANCE_METERS ? idx : -1;
}


function createIcon(userId, color){
  return L.divIcon({
    html:`<div style="font-size:26px;font-weight:bold;color:${color}">${userId}</div>`,
    className:"",
    iconSize:[30,30],
    iconAnchor:[15,15]
  });
}

async function route(a,b){
  const url=`https://router.project-osrm.org/route/v1/driving/${a[1]},${a[0]};${b[1]},${b[0]}?overview=full&geometries=geojson`;
  const r = await fetch(url).then(r=>r.json());
  return r.routes[0].geometry.coordinates.map(c=>[c[1],c[0]]);
}

function randomColor(){
  return "#" + Math.floor(Math.random()*16777215).toString(16).padStart(6,"0");
}

/* ================= CREATE USER ================= */
async function createUser(role){
  currentUserId = await getNextUserId(); // nowy numer: 1,2,3...
  currentRole = role;

  const userColor = role === "driver" ? randomColor() : "green";

const startMarker = L.marker([0,0], {
  icon: createIcon(currentUserId, userColor)
}).addTo(map);

const endMarker = L.marker([0,0], {
  icon: createIcon(currentUserId, userColor)
}).addTo(map);

const line = L.polyline([], {
  color: userColor,
  weight: 5
}).addTo(map);

  usersMarkers[currentUserId] = {
  startMarker,
  endMarker,
  line,
  role,
  color: userColor,
  matchingDrivers: [],
  currentDriverIndex: 0
};



  navigator.geolocation.getCurrentPosition(p=>{
    const lat=p.coords.latitude, lng=p.coords.longitude;
    startMarker.setLatLng([lat,lng]);
    db.ref(`session/users/${currentUserId}`).set({
  role,
  color: userColor,
  currentLocation:{ latitude:lat, longitude:lng }
});
  });

  if(role==="driver") document.getElementById("driverDestinationDiv").style.display="block";
  if(role==="passenger") document.getElementById("passengerControls").style.display="block";

  // blokada przycisków ról po wyborze
  document.getElementById("driverBtn").disabled=true;
  document.getElementById("driverBtn").style.opacity="0.4";
  document.getElementById("passengerBtn").disabled=true;
  document.getElementById("passengerBtn").style.opacity="0.4";
}

/* ================= MAP CLICK ================= */
map.on("click", function(e){
  if(!editingDestination && !editingStart) return;
  selectedPoint=[e.latlng.lat,e.latlng.lng];
  if(editingDestination) usersMarkers[currentUserId].endMarker.setLatLng(selectedPoint);
  if(editingStart) usersMarkers[currentUserId].startMarker.setLatLng(selectedPoint);
  drawUserRoute(currentUserId);
});

/* ================= DRAW ROUTE ================= */
async function drawUserRoute(userId){
  const user = usersMarkers[userId];
  if(!user) return;
  const start = user.startMarker.getLatLng();
  const end = user.endMarker.getLatLng();
  const coords = await route([start.lat,start.lng],[end.lat,end.lng]);
  user.line.setLatLngs(coords);
}

/* ================= SAVE BUTTONS ================= */
const saveDriverDestinationBtn = document.getElementById("saveDriverDestinationBtn");
saveDriverDestinationBtn.onclick = async ()=>{
  if(!editingDestination){editingDestination=true; saveDriverDestinationBtn.innerText="Zapisz cel"; return;}
  if(selectedPoint){
    usersMarkers[currentUserId].endMarker.setLatLng(selectedPoint);
    db.ref(`session/users/${currentUserId}/destination`).set({latitude:selectedPoint[0],longitude:selectedPoint[1]});
    drawUserRoute(currentUserId);
  }
  editingDestination=false;
  saveDriverDestinationBtn.innerText="Edytuj cel";
  selectedPoint=null;
};

// ================= SAVE DESTINATION =================
const saveDestinationBtn = document.getElementById("saveDestinationBtn");
saveDestinationBtn.onclick = async () => {
  if (!editingDestination) {
    editingDestination = true;
    saveDestinationBtn.innerText = "Zapisz cel";
    return;
  }

  if (selectedPoint) {
    usersMarkers[currentUserId].endMarker.setLatLng(selectedPoint);
    await db.ref(`session/users/${currentUserId}/destination`).set({
      latitude: selectedPoint[0],
      longitude: selectedPoint[1]
    });

    await drawUserRoute(currentUserId);

    if (currentRole === "passenger") {
      await findMatchingDrivers(currentUserId);
      showCurrentDriver();
    }
  }

  editingDestination = false;
  saveDestinationBtn.innerText = "Edytuj cel";
  selectedPoint = null;
};

// ================= SAVE START =================
const saveStartBtn = document.getElementById("saveStartBtn");
saveStartBtn.onclick = async () => {
  if (!editingStart) {
    editingStart = true;
    saveStartBtn.innerText = "Zapisz start";
    return;
  }

  if (selectedPoint) {
    usersMarkers[currentUserId].startMarker.setLatLng(selectedPoint);
    await db.ref(`session/users/${currentUserId}/currentLocation`).set({
      latitude: selectedPoint[0],
      longitude: selectedPoint[1]
    });

    await drawUserRoute(currentUserId);

    if (currentRole === "passenger") {
      await findMatchingDrivers(currentUserId);
      showCurrentDriver();
    }
  }

  editingStart = false;
  saveStartBtn.innerText = "Edytuj start";
  selectedPoint = null;
};



/* ================= MODE ================= */
const modeBtn = document.getElementById("modeBtn");
modeBtn.onclick = ()=>{
  const newMode = currentMode==="A"?"B":"A";
  db.ref("session/mode").set(newMode);
};

// Funkcja do odświeżania dopasowań po zmianie trybu
function checkOverlaps(){
  if(currentRole==="passenger"){
    findMatchingDrivers(currentUserId).then(()=>showCurrentDriver());
  }
}

db.ref("session/mode").on("value", snap=>{
  if(snap.val()) currentMode = snap.val();
  modeBtn.innerText = "Tryb " + currentMode;
  checkOverlaps(); // teraz już istnieje, nie powoduje błędu
});


/* ================= OVERLAP ================= */
//const TOLERANCE_METERS = 150; // zwiększona tolerancja, aby łatwiej dopasować trasę

async function findMatchingDrivers(passengerId) {
  const passenger = usersMarkers[passengerId];
  if (!passenger) return;

  passenger.matchingDrivers = [];
  passenger.currentDriverIndex = 0;

  const pStart = passenger.startMarker.getLatLng();
  console.log("Passenger start:", pStart);

  for (let uid in usersMarkers) {
    const driver = usersMarkers[uid];
    if (driver.role !== "driver") continue;

    const path = driver.line.getLatLngs();
    if (!path || path.length === 0) continue;

    // 1️⃣ start pasażera na trasie kierowcy
    const startIdx = findClosestIndex(
      [pStart.lat, pStart.lng],
      path
    );
    if (startIdx === -1) continue;

// 2️⃣ szukamy OSTATNIEGO przecięcia tras (pierwsze od końca)
let endIdx = -1;
const passengerPath = passenger.line.getLatLngs();

for (let i = path.length - 1; i > startIdx; i--) {
  const p = path[i];
  const idxOnPassenger = findClosestIndex(
    [p.lat, p.lng],
    passengerPath
  );

  if (idxOnPassenger !== -1) {
    endIdx = i;
    break; // PIERWSZE od tyłu = OSTATNIE logicznie
  }
}

// jeśli brak drugiego przecięcia → NIE Tryb A
if (endIdx === -1) continue;

passenger.matchingDrivers.push({
  driverId: uid,
  fromIndex: startIdx,
  toIndex: endIdx
});
  }

  console.log("Matching drivers (MODE A):", passenger.matchingDrivers);

  if (passenger.matchingDrivers.length > 0) {
    document.getElementById("driverBrowseControls").style.display = "flex";
  } else {
    overlapLine.setLatLngs([]);
    document.getElementById("driverBrowseControls").style.display = "none";
  }
}



// Wyświetla trasę aktualnego dopasowanego kierowcy
function showCurrentDriver() {
  overlapLine.setLatLngs([]);

  const passenger = usersMarkers[currentUserId];
  if (!passenger || passenger.matchingDrivers.length === 0) return;

  const match = passenger.matchingDrivers[passenger.currentDriverIndex];
  const driver = usersMarkers[match.driverId];
  if (!driver) return;

  const path = driver.line.getLatLngs();
  overlapLine.setLatLngs(
    path.slice(match.fromIndex, match.toIndex + 1)
  );
}



// Guziki do przełączania między kierowcami
document.getElementById("nextDriverBtn").onclick = () => {
  const passenger = usersMarkers[currentUserId];
  if (!passenger) return;

  if (passenger.currentDriverIndex < passenger.matchingDrivers.length - 1) {
    passenger.currentDriverIndex++;
    showCurrentDriver();
  }
};

document.getElementById("prevDriverBtn").onclick = () => {
  const passenger = usersMarkers[currentUserId];
  if (!passenger) return;

  if (passenger.currentDriverIndex > 0) {
    passenger.currentDriverIndex--;
    showCurrentDriver();
  }
};





/* ================= EVENTY ROLE ================= */
document.getElementById("driverBtn").onclick = ()=>{document.body.style.backgroundColor="#2f6fff"; createUser("driver");};
document.getElementById("passengerBtn").onclick = ()=>{document.body.style.backgroundColor="#2fbf6f"; createUser("passenger");};

/* ================= SYNC USERS ================= */
/* ================= SYNC USERS – pełna synchronizacja ================= */
db.ref("session/users").on("value", async snap => {
  const allUsers = snap.val() || {};

  for (let uid in allUsers) {
    const data = allUsers[uid];

    // jeśli użytkownik już istnieje w usersMarkers, aktualizujemy markery i trasę
    if (usersMarkers[uid]) {
      const user = usersMarkers[uid];

      // aktualizacja startu
      if (data.currentLocation) {
        user.startMarker.setLatLng([data.currentLocation.latitude, data.currentLocation.longitude]);
      }

      // aktualizacja celu
      if (data.destination) {
        user.endMarker.setLatLng([data.destination.latitude, data.destination.longitude]);
      }

      // aktualizacja linii
      if (data.currentLocation && data.destination) {
        await drawUserRoute(uid);
      }

      continue; // idziemy do następnego uid
    }

    // jeśli użytkownik jeszcze nie istnieje → tworzymy
    const role = data.role;
    const color = data.color || (role === "driver" ? randomColor() : "green");

    const startLat = data.currentLocation?.latitude || 0;
    const startLng = data.currentLocation?.longitude || 0;

    const endLat = data.destination?.latitude || startLat;
    const endLng = data.destination?.longitude || startLng;

    const startMarker = L.marker([startLat, startLng], { icon: createIcon(uid, color) }).addTo(map);
    const endMarker = L.marker([endLat, endLng], { icon: createIcon(uid, color) }).addTo(map);
    const line = L.polyline([], { color, weight: 5 });

if (currentRole === "driver") {
  line.addTo(map);
}


    usersMarkers[uid] = { startMarker, endMarker, line, role, color };

    // rysowanie trasy jeśli są dane start + cel
    if (data.currentLocation && data.destination) {
      await drawUserRoute(uid);
    }
  }

  // jeśli jesteśmy pasażerem → sprawdzamy dopasowania
  if (currentRole === "passenger" && currentUserId) {
    await findMatchingDrivers(currentUserId);
    showCurrentDriver();
  }
});


</script>

</body>
</html>
