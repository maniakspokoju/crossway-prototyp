Czytelne,  dzielone pola, akceptacja nie działa, 

<!DOCTYPE html>
<html lang="pl">
<head>
<meta charset="UTF-8">
<title>Crossway – Szachownica</title>
<style>
  body { font-family: Arial, sans-serif; }
  #roleSelect { margin: 10px 0; }
  #grid { border-collapse: collapse; margin: 20px 0; }
  #grid td { width: 40px; height: 40px; border: 1px solid #aaa; text-align: center; vertical-align: middle; cursor: pointer; }
  .driverCell { background-color: #90ee90; }
  .passengerCell { background-color: #add8e6; }
  .sharedCell { background: linear-gradient(45deg, #90ee90 50%, #add8e6 50%); }
  #usersTable { margin-top: 20px; border-collapse: collapse; width: 100%; }
  #usersTable th, #usersTable td { border: 1px solid #000; padding: 5px; text-align: center; }
  #controls { margin-top: 10px; }
</style>
<script src="https://www.gstatic.com/firebasejs/9.22.1/firebase-app-compat.js"></script>
<script src="https://www.gstatic.com/firebasejs/9.22.1/firebase-database-compat.js"></script>
</head>
<body>

<h1>Crossway – Szachownica</h1>

<div id="roleSelect">
  <button id="driverBtn">Kierowca</button>
  <button id="passengerBtn">Pasażer</button>
</div>

<div id="controls">
  <button id="prevDriverBtn">⬅ Cofnij</button>
  <button id="nextDriverBtn">➡ Dalej</button>
  <button id="acceptBtn">✅ Akceptuj</button>
</div>

<table id="grid"></table>

<h2>Użytkownicy / trasy</h2>
<table id="usersTable">
  <thead>
    <tr>
      <th>ID</th>
      <th>Rola</th>
      <th>Start</th>
      <th>Cel</th>
      <th>Na trasie kierowcy?</th>
    </tr>
  </thead>
  <tbody></tbody>
</table>

<script>
  // ====== CONFIG FIREBASE ======
  const firebaseConfig = {
    apiKey: "YOUR_API_KEY",
    authDomain: "YOUR_AUTH_DOMAIN",
    databaseURL: "https://crossway-prototyp-default-rtdb.europe-west1.firebasedatabase.app",
    projectId: "crossway-prototyp",
    storageBucket: "YOUR_BUCKET",
    messagingSenderId: "YOUR_SENDER_ID",
    appId: "YOUR_APP_ID"
  };
  const app = firebase.initializeApp(firebaseConfig);
  const db = firebase.database();

  // ====== STANY ======
  const ROWS = 8, COLS = 8;
  let userId = crypto.randomUUID();
  let role = null; // 'driver' lub 'passenger'
  let gridStart = null;
  let gridEnd = null;
  let usersData = {};
  let matchedDrivers = [];
  let selectedDriverIndex = 0;

  // ====== ELEMENTY ======
  const gridEl = document.getElementById('grid');
  const driverBtn = document.getElementById('driverBtn');
  const passengerBtn = document.getElementById('passengerBtn');
  const prevDriverBtn = document.getElementById('prevDriverBtn');
  const nextDriverBtn = document.getElementById('nextDriverBtn');
  const acceptBtn = document.getElementById('acceptBtn');
  const usersTableBody = document.querySelector('#usersTable tbody');

  // ====== INICJALIZACJA GRIDU ======
  function initGrid() {
    gridEl.innerHTML = '';
    for(let r=0;r<ROWS;r++){
      let tr = document.createElement('tr');
      for(let c=0;c<COLS;c++){
        let td = document.createElement('td');
        td.dataset.row = r;
        td.dataset.col = c;
        td.onclick = () => cellClick(r,c);
        tr.appendChild(td);
      }
      gridEl.appendChild(tr);
    }
  }

  function cellClick(r,c){
    if(!role) return;
    if(!gridStart){
      gridStart = {r,c};
      updateGrid();
    } else if(!gridEnd){
      gridEnd = {r,c};
      // sprawdzamy linia prosta
      if(gridStart.r !== gridEnd.r && gridStart.c !== gridEnd.c){
        alert("Trasa musi być w linii prostej!");
        gridEnd = null;
        return;
      }
      saveRoute();
      updateGrid();
    }
  }

  function saveRoute(){
    const start = `${gridStart.r},${gridStart.c}`;
    const end = `${gridEnd.r},${gridEnd.c}`;
    db.ref("users/"+userId).set({
      role,
      start,
      end,
      acceptedBy: null
    });
  }

  function updateGrid(){
    for(let r=0;r<ROWS;r++){
      for(let c=0;c<COLS;c++){
        const td = gridEl.rows[r].cells[c];
        td.className = '';
      }
    }
    if(gridStart) gridEl.rows[gridStart.r].cells[gridStart.c].classList.add('driverCell');
    if(gridEnd) gridEl.rows[gridEnd.r].cells[gridEnd.c].classList.add('driverCell');

    // renderowanie tras
    if(role==='driver' && gridStart && gridEnd){
      drawRoute(gridStart, gridEnd, 'driverCell');
    }

    // jeśli pasażer + wybrany kierowca
    if(role==='passenger' && gridStart && gridEnd && matchedDrivers[selectedDriverIndex]){
      drawRoute(gridStart, gridEnd, 'passengerCell'); // jego trasa
      const driver = matchedDrivers[selectedDriverIndex];
      const dStart = parseCell(driver.start);
      const dEnd = parseCell(driver.end);
      drawRoute(dStart, dEnd, 'driverCell');

      // sprawdzamy wspólne pola
      const shared = getSharedCells(gridStart, gridEnd, dStart, dEnd);
      shared.forEach(cell=>{
        gridEl.rows[cell.r].cells[cell.c].classList.add('sharedCell');
      });
    }
  }

  function drawRoute(start,end,className){
    if(start.r===end.r){
      for(let c=Math.min(start.c,end.c);c<=Math.max(start.c,end.c);c++)
        gridEl.rows[start.r].cells[c].classList.add(className);
    } else {
      for(let r=Math.min(start.r,end.r);r<=Math.max(start.r,end.r);r++)
        gridEl.rows[r].cells[start.c].classList.add(className);
    }
  }

  function parseCell(str){
    const [r,c] = str.split(',').map(Number);
    return {r,c};
  }

  function getSharedCells(start1,end1,start2,end2){
    const shared = [];
    const cells1 = [];
    const cells2 = [];

    if(start1.r===end1.r)
      for(let c=Math.min(start1.c,end1.c);c<=Math.max(start1.c,end1.c);c++) cells1.push({r:start1.r,c});
    else
      for(let r=Math.min(start1.r,end1.r);r<=Math.max(start1.r,end1.r);r++) cells1.push({r,c:start1.c});

    if(start2.r===end2.r)
      for(let c=Math.min(start2.c,end2.c);c<=Math.max(start2.c,end2.c);c++) cells2.push({r:start2.r,c});
    else
      for(let r=Math.min(start2.r,end2.r);r<=Math.max(start2.r,end2.r);r++) cells2.push({r,c:start2.c});

    cells1.forEach(c1=>{
      if(cells2.some(c2=>c2.r===c1.r && c2.c===c1.c)) shared.push(c1);
    });

    return shared;
  }

  // ====== OBSŁUGA GŁÓWNYCH PRZYCISKÓW ======
  driverBtn.onclick = ()=>{
    role='driver';
    gridStart=null; gridEnd=null;
    document.body.style.backgroundColor="#ddffdd";
    initGrid();
  };
  passengerBtn.onclick = ()=>{
    role='passenger';
    gridStart=null; gridEnd=null;
    document.body.style.backgroundColor="#ddeeff";
    initGrid();
  };

  nextDriverBtn.onclick = ()=>{
    if(matchedDrivers.length===0) return;
    selectedDriverIndex = (selectedDriverIndex+1) % matchedDrivers.length;
    updateGrid();
  };
  prevDriverBtn.onclick = ()=>{
    if(matchedDrivers.length===0) return;
    selectedDriverIndex = (selectedDriverIndex-1 + matchedDrivers.length) % matchedDrivers.length;
    updateGrid();
  };
  acceptBtn.onclick = ()=>{
    if(role!=='passenger') return;
    const driver = matchedDrivers[selectedDriverIndex];
    db.ref("users/"+driver.id+"/acceptedBy").set(userId);
  };

  // ====== OBSŁUGA DANYCH Z FIREBASE ======
  function refreshUsers(snapshot){
    usersData = snapshot.val() || {};
    updateUsersTable();

    // dla pasażera: znajdź pasujących kierowców
    if(role==='passenger'){
      matchedDrivers = Object.entries(usersData)
        .filter(([id,u])=> u.role==='driver' && u.start && u.end)
        .filter(([id,u])=>{
          const ps = gridStart;
          if(!ps) return false;
          const dStart = parseCell(u.start);
          const dEnd = parseCell(u.end);
          // pasujący jeśli start pasażera leży na trasie kierowcy
          const cells = (dStart.r===dEnd.r)
            ? Array.from({length:Math.abs(dEnd.c-dStart.c)+1},(_,i)=>({r:dStart.r,c:Math.min(dStart.c,dEnd.c)+i}))
            : Array.from({length:Math.abs(dEnd.r-dStart.r)+1},(_,i)=>({r:Math.min(dStart.r,dEnd.r)+i,c:dStart.c}));
          return cells.some(c=>c.r===ps.r && c.c===ps.c);
        }).map(([id,u])=> ({id,...u}));
      selectedDriverIndex=0;
      updateGrid();
    }

    // dla kierowcy: sprawdź akceptacje pasażerów
    if(role==='driver') updateGrid();
  }

  function updateUsersTable(){
    usersTableBody.innerHTML='';
    Object.entries(usersData).forEach(([id,u])=>{
      const tr = document.createElement('tr');
      tr.innerHTML=`<td>${id}</td><td>${u.role||''}</td><td>${u.start||''}</td><td>${u.end||''}</td><td>${u.acceptedBy?u.acceptedBy:''}</td>`;
      usersTableBody.appendChild(tr);
    });
  }

  db.ref("users").on('value',refreshUsers);

  // ====== START ======
  initGrid();
</script>
</body>
</html>
