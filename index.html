<!DOCTYPE html>
<html lang="pl">
<head>
<meta charset="UTF-8">
<title>Crossway â€“ Szachownica</title>
<style>
  body { font-family: Arial, sans-serif; }
  #roleSelect { margin: 10px 0; }
  #grid { border-collapse: collapse; margin: 20px 0; }
  #grid td { width: 40px; height: 40px; border: 1px solid #aaa; text-align: center; vertical-align: middle; cursor: pointer; position: relative; }
  .sharedCell { background-color: red !important; }
  #usersTable { margin-top: 20px; border-collapse: collapse; width: 100%; }
  #usersTable th, #usersTable td { border: 1px solid #000; padding: 5px; text-align: center; }
  #controls { margin-top: 10px; }
  .driverCell, .passengerCell { color: #000; font-weight: bold; }
#mainView {
  display: flex;
  gap: 20px;
  align-items: flex-start;
}

#map {
  width: 360px;
  height: 360px;
  border: 1px solid #aaa;
}

</style>
<script src="https://www.gstatic.com/firebasejs/9.22.1/firebase-app-compat.js"></script>
<script src="https://www.gstatic.com/firebasejs/9.22.1/firebase-database-compat.js"></script>
<link
  rel="stylesheet"
  href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css"
/>
<script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
<link rel="stylesheet" href="https://unpkg.com/leaflet-routing-machine/dist/leaflet-routing-machine.css" />
<script src="https://unpkg.com/leaflet-routing-machine/dist/leaflet-routing-machine.min.js"></script>
</head>
<body>

															<h1>Crossway â€“ Szachownica 5.4.1</h1>

<div id="roleSelect">
  <button id="driverBtn">Kierowca</button>
  <button id="passengerBtn">PasaÅ¼er</button>
</div>

<div id="controls">
  <button id="prevDriverBtn">â¬… Cofnij</button>
  <button id="nextDriverBtn">âž¡ Dalej</button>
  <button id="acceptBtn">âœ… Akceptuj</button>
  <button id="resetBtn">ðŸ›‘ ZakoÅ„cz przejazd</button>
  <button id="goalBtn">ðŸŽ¯ Edytuj cel</button>
</div>


<div id="assignedPassenger" style="margin-top:10px; font-weight:bold;"></div>



<div id="mainView">
  <table id="grid"></table>
  <div id="map"></div>
</div>


<h2>UÅ¼ytkownicy / trasy</h2>
<table id="usersTable">
  <thead>
   <tr id="usersHeader">
  <th>ID</th>
  <th>Kolor</th>
</tr>

  </thead>
  <tbody></tbody>
</table>

<script>
  // ====== CONFIG FIREBASE ======
  const firebaseConfig = {
    apiKey: "YOUR_API_KEY",
    authDomain: "YOUR_AUTH_DOMAIN",
    databaseURL: "https://crossway-prototyp-default-rtdb.europe-west1.firebasedatabase.app",
    projectId: "crossway-prototyp",
    storageBucket: "YOUR_BUCKET",
    messagingSenderId: "YOUR_SENDER_ID",
    appId: "YOUR_APP_ID"
  };
  const app = firebase.initializeApp(firebaseConfig);
  const db = firebase.database();

  // ====== STANY ======
  const ROWS = 8, COLS = 8;
  let userId = null; // zostanie ustawione po pobraniu numeru
  let userNumber = null;
  let role = null; // 'driver' lub 'passenger'
  let gridStart = null;
  let gridEnd = null;
  let usersData = {};
  let matchedDrivers = [];
  let selectedDriverIndex = 0;
  let passengersOrder = []; // [1,2,3...] â€“ kolejnoÅ›Ä‡ pasaÅ¼erÃ³w
  let acceptedDriverId = null; // ID kierowcy zaakceptowanego przez pasaÅ¼era
  let myColor = null;          // kolor TEGO uÅ¼ytkownika
  let userLocation = null;    // { lat, lng }
  let myMarker = null;        // marker Leaflet
  let goalEditMode = false;   // czy edytujemy cel
  let goalMarker = null;     // marker celu
  let goalLocation = null;   // { lat, lng }
  let routeControl = null; // globalny obiekt trasy
  let startMarker = null;  // marker startu uÅ¼ytkownika





 


  const driverColors = {};

  // ====== ELEMENTY ======
  const gridEl = document.getElementById('grid');
  const driverBtn = document.getElementById('driverBtn');
  const passengerBtn = document.getElementById('passengerBtn');
  const prevDriverBtn = document.getElementById('prevDriverBtn');
  const nextDriverBtn = document.getElementById('nextDriverBtn');
  const acceptBtn = document.getElementById('acceptBtn');
  const resetBtn = document.getElementById('resetBtn');
  const usersTableBody = document.querySelector('#usersTable tbody');
  const goalBtn = document.getElementById('goalBtn');

  // ====== INICJALIZACJA GRIDU ======
  function initGrid() {
    gridEl.innerHTML = '';
    const header = document.createElement('tr');
    header.innerHTML = '<th></th>' + Array.from({length:COLS}, (_,i)=>`<th>${String.fromCharCode(65+i)}</th>`).join('');
    gridEl.appendChild(header);
    for(let r=0;r<ROWS;r++){
      let tr = document.createElement('tr');
      tr.innerHTML = `<th>${r+1}</th>`;
      for(let c=0;c<COLS;c++){
        let td = document.createElement('td');
        td.dataset.row = r;
        td.dataset.col = c;
        td.onclick = () => cellClick(r,c);
        tr.appendChild(td);
      }
      gridEl.appendChild(tr);
    }
  }

  function cellClick(r,c){
    if(!role) return;
    if(!gridStart){
      gridStart = {r,c};
      updateGrid();
    } else if(!gridEnd){
      gridEnd = {r,c};
      if(gridStart.r !== gridEnd.r && gridStart.c !== gridEnd.c){
        alert("Trasa musi byÄ‡ w linii prostej!");
        gridEnd = null;
        return;
      }
      saveRoute();
      updateGrid();
    }
  }

function updateUsersHeader(){
  const thead = document.querySelector('#usersTable thead');

  thead.innerHTML = `
    <tr>
      <th>#</th>
      <th>Kolor</th>
      ${passengersOrder.map(n => `<th>${n}</th>`).join('')}
    </tr>
  `;
}


function passengerOnDriverRoute(passenger, driver){
  if(!passenger.start || !driver.start) return false;

  const ps = parseCell(passenger.start);
  const ds = parseCell(driver.start);
  const de = parseCell(driver.end);

  const cells = (ds.r===de.r)
    ? Array.from({length:Math.abs(de.c-ds.c)+1},(_,i)=>({r:ds.r,c:Math.min(ds.c,de.c)+i}))
    : Array.from({length:Math.abs(de.r-ds.r)+1},(_,i)=>({r:Math.min(ds.r,de.r)+i,c:ds.c}));

  return cells.some(c=>c.r===ps.r && c.c===ps.c);
}



function saveRoute(){
  if(!userId){
    assignUserNumber(saveRoute);
    return;
  }

  const start = `${gridStart.r},${gridStart.c}`;
  const end = `${gridEnd.r},${gridEnd.c}`;
if (role === 'driver' && !myColor) {
  myColor = getRandomColor();
}

const color = role === 'driver' ? myColor : null;


db.ref("users/"+userId).set({
  number: userNumber,
  role,
  start,
  end,
  color,
  acceptedBy: null
});

// â¬‡â¬‡â¬‡ DOKÅADNIE TUTAJ
tryCreateMyMarker();


  // ðŸ”¹ dezaktywacja przyciskÃ³w po ustaleniu trasy kierowcy
  if(role === 'driver') {
    prevDriverBtn.disabled = true;
    nextDriverBtn.disabled = true;
    acceptBtn.disabled = true;
  }
}

function isSameDirection(driverStart, driverEnd, passengerStart, passengerEnd){
  // tylko trasy w linii prostej (tak jak w Twoim programie)
  if(driverStart.r === driverEnd.r){
    // poziomo
    const dirDriver = Math.sign(driverEnd.c - driverStart.c);
    const dirPassenger = Math.sign(passengerEnd.c - passengerStart.c);
    return dirDriver === dirPassenger;
  }

  if(driverStart.c === driverEnd.c){
    // pionowo
    const dirDriver = Math.sign(driverEnd.r - driverStart.r);
    const dirPassenger = Math.sign(passengerEnd.r - passengerStart.r);
    return dirDriver === dirPassenger;
  }

  return false;
}



function assignUserNumber(callback){
  const ref = db.ref("meta/nextUserNumber");
  ref.transaction(current => {
    return (current || 0) + 1;
  }, (error, committed, snapshot) => {
if(committed){
  userNumber = snapshot.val();
  userId = String(userNumber);
  tryCreateMyMarker();
  callback();
}
  });
}


  function getRandomColor(){
    const letters = '0123456789ABCDEF';
    let color = '#';
    for(let i=0;i<6;i++) color += letters[Math.floor(Math.random()*16)];
    return color;
  }

function tryCreateMyMarker() {
  if (!map) return;
  if (!userId) return;
  if (!userNumber) return;
  if (!myColor) return;
  if (!userLocation) return;
  if (myMarker) return; // â— nie tworzymy drugi raz

  const icon = L.divIcon({
    className: '',
    html: `
      <div style="
        background:${myColor};
        color:#fff;
        width:26px;
        height:26px;
        border-radius:50%;
        text-align:center;
        line-height:26px;
        font-weight:bold;
        border:2px solid #000;
      ">${userNumber}</div>
    `,
    iconSize: [26,26],
    iconAnchor: [13,13]
  });

  myMarker = L.marker(
    [userLocation.lat, userLocation.lng],
    { icon }
  ).addTo(map);

  map.setView([userLocation.lat, userLocation.lng], 14);
}


function getUserLocation() {
  if (!navigator.geolocation) {
    alert("Brak obsÅ‚ugi GPS");
    return;
  }

navigator.geolocation.getCurrentPosition(pos => {
  const lat = pos.coords.latitude;
  const lng = pos.coords.longitude;

  userLocation = { lat, lng };

  // ðŸ”¹ utworzenie lub przesuniÄ™cie markera startu
  if (!startMarker) {
    startMarker = L.marker([lat, lng], { color: role === 'driver' ? driverColors[userId] : 'green' })
                  .addTo(map)
                  .bindPopup('Start');
  } else {
    startMarker.setLatLng([lat, lng]);
  }

  // ðŸ”¹ oryginalna funkcja tworzÄ…ca marker uÅ¼ytkownika
  tryCreateMyMarker();

}, err => {
  alert("Nie udaÅ‚o siÄ™ pobraÄ‡ lokalizacji");
});
}

function clearGridVisuals() {
  for (let r = 0; r < ROWS; r++) {
    for (let c = 0; c < COLS; c++) {
      const cell = gridEl.rows[r + 1].cells[c + 1];
      cell.style.backgroundColor = '';
      cell.className = '';
    }
  }
}


function updateGrid(){
  clearGridVisuals();

    // reset
    for(let r=0;r<ROWS;r++)
      for(let c=0;c<COLS;c++)
        gridEl.rows[r+1].cells[c+1].className='';

    if(gridStart) gridEl.rows[gridStart.r+1].cells[gridStart.c+1].classList.add(role==='driver' ? 'driverCell' : 'passengerCell');
    if(gridEnd) gridEl.rows[gridEnd.r+1].cells[gridEnd.c+1].classList.add(role==='driver' ? 'driverCell' : 'passengerCell');

    // dla kierowcy rysujemy wÅ‚asnÄ… trasÄ™
if(role==='driver' && gridStart && gridEnd){
  // wÅ‚asna trasa kierowcy
  drawRoute(gridStart, gridEnd, driverColors[userId] || 'blue');

  // rysujemy trasÄ™ wszystkich pasaÅ¼erÃ³w, ktÃ³rzy zaakceptowali tego kierowcÄ™
  Object.values(usersData).forEach(u => {
    if(u.role === 'passenger' && u.acceptedDriverId == userId && u.start && u.end){
      const pStart = parseCell(u.start);
      const pEnd = parseCell(u.end);

      // trasa pasaÅ¼era
      drawRoute(pStart, pEnd, 'green');

      // wspÃ³lne pola
      const shared = getSharedCells(gridStart, gridEnd, pStart, pEnd);
      shared.forEach(cell => {
        gridEl.rows[cell.r+1].cells[cell.c+1].classList.add('sharedCell');
      });
    }
  });
}



    // dla pasaÅ¼era
if(role==='passenger' && gridStart && gridEnd){
  // zawsze wÅ‚asna trasa pasaÅ¼era
  drawRoute(gridStart, gridEnd, 'passengerCell');

  // jeÅ›li jeszcze nie zaakceptowaÅ‚ â€“ rysujemy trasÄ™ aktualnie wybranego kierowcy
  if(!acceptedDriverId && matchedDrivers[selectedDriverIndex]){
    const driver = matchedDrivers[selectedDriverIndex];
    const dStart = parseCell(driver.start);
    const dEnd = parseCell(driver.end);
    drawRoute(dStart, dEnd, driver.color || 'blue');

    const shared = getSharedCells(gridStart, gridEnd, dStart, dEnd);
    shared.forEach(cell => {
      gridEl.rows[cell.r + 1].cells[cell.c + 1].classList.add('sharedCell');
    });
  }

  // jeÅ›li zaakceptowaÅ‚ â€“ rysujemy tylko trasÄ™ zaakceptowanego kierowcy + wspÃ³lne pola
  if(acceptedDriverId){
    const driver = usersData[acceptedDriverId];
    if(driver && driver.start && driver.end){
      const dStart = parseCell(driver.start);
      const dEnd = parseCell(driver.end);
      drawRoute(dStart, dEnd, driver.color || 'blue');

      const shared = getSharedCells(gridStart, gridEnd, dStart, dEnd);
      shared.forEach(cell => {
        gridEl.rows[cell.r + 1].cells[cell.c + 1].classList.add('sharedCell');
      });
    }
  }
}
}

  function drawRoute(start,end,className){
    const color = className==='driverCell' ? 'blue' : className==='passengerCell' ? 'green' : className;
    if(start.r===end.r)
      for(let c=Math.min(start.c,end.c);c<=Math.max(start.c,end.c);c++)
        gridEl.rows[start.r+1].cells[c+1].style.backgroundColor=color;
    else
      for(let r=Math.min(start.r,end.r);r<=Math.max(start.r,end.r);r++)
        gridEl.rows[r+1].cells[start.c+1].style.backgroundColor=color;
  }

  function parseCell(str){
    const [r,c] = str.split(',').map(Number);
    return {r,c};
  }

  function getSharedCells(start1,end1,start2,end2){
    const cells1 = (start1.r===end1.r)
      ? Array.from({length:Math.abs(end1.c-start1.c)+1},(_,i)=>({r:start1.r,c:Math.min(start1.c,end1.c)+i}))
      : Array.from({length:Math.abs(end1.r-start1.r)+1},(_,i)=>({r:Math.min(start1.r,end1.r)+i,c:start1.c}));
    const cells2 = (start2.r===end2.r)
      ? Array.from({length:Math.abs(end2.c-start2.c)+1},(_,i)=>({r:start2.r,c:Math.min(start2.c,end2.c)+i}))
      : Array.from({length:Math.abs(end2.r-start2.r)+1},(_,i)=>({r:Math.min(start2.r,end2.r)+i,c:start2.c}));
    return cells1.filter(c1=>cells2.some(c2=>c1.r===c2.r && c1.c===c2.c));
  }

  // ====== PRZYCISKI ======
driverBtn.onclick = () => {
  role = 'driver';
  document.body.style.backgroundColor = "#ddeeff";
  driverBtn.disabled = true; passengerBtn.disabled = true;

  // natychmiastowy numer i kolor
  assignUserNumber(() => {
    myColor = getRandomColor(); // losowy kolor kierowcy
    updateUsersTable();          // od razu dodajemy do tabeli
  });

  getUserLocation(); // pobieramy GPS
};

passengerBtn.onclick = () => {
  role = 'passenger';
  document.body.style.backgroundColor = "#ddffdd";
  driverBtn.disabled = true; passengerBtn.disabled = true;

  // natychmiastowy numer i kolor
  assignUserNumber(() => {
    myColor = 'green';           // staÅ‚y kolor pasaÅ¼era
    updateUsersTable();          // od razu dodajemy do tabeli
  });

  getUserLocation(); // pobieramy GPS
};


  nextDriverBtn.onclick = ()=>{
    if(matchedDrivers.length===0) return;
    selectedDriverIndex=(selectedDriverIndex+1)%matchedDrivers.length;
    updateGrid();
  };
  prevDriverBtn.onclick = ()=>{
    if(matchedDrivers.length===0) return;
    selectedDriverIndex=(selectedDriverIndex-1+matchedDrivers.length)%matchedDrivers.length;
    updateGrid();
  };

acceptBtn.onclick = () => {
  if(role !== 'passenger') return;

  const driver = matchedDrivers[selectedDriverIndex];
  acceptedDriverId = driver.id; // zapisujemy zaakceptowanego kierowcÄ™

  // ðŸ”¹ zapis w pasaÅ¼erze: ktÃ³rego kierowcÄ™ zaakceptowaÅ‚
  const passengerRef = db.ref("users/" + userId + "/acceptedDriverId");
  passengerRef.set(driver.id);

  // opcjonalnie: dla kierowcy teÅ¼ moÅ¼emy aktualizowaÄ‡ listÄ™ pasaÅ¼erÃ³w
  const driverRef = db.ref("users/" + driver.id + "/acceptedBy");
  driverRef.transaction(current => {
    if(!current) return [userNumber];
    if(!current.includes(userNumber)) current.push(userNumber);
    return current;
  });

  // dezaktywacja przyciskÃ³w
  prevDriverBtn.disabled = true;
  nextDriverBtn.disabled = true;
  acceptBtn.disabled = true;
};




  resetBtn.onclick = ()=>{
    db.ref("users").remove();
    db.ref("meta").remove(); // â¬… reset licznika
    gridStart=null; gridEnd=null;
    usersData={};
    matchedDrivers=[];
    selectedDriverIndex=0;
    driverBtn.disabled=false; passengerBtn.disabled=false;
    initGrid();
  };

goalBtn.onclick = () => {
  goalEditMode = !goalEditMode;

  if (goalEditMode) {
    goalBtn.textContent = 'ðŸ’¾ Zapisz cel';
  } else {
    // Zapisanie celu i rysowanie trasy
    goalEditMode = false;
    goalBtn.textContent = 'ðŸŽ¯ Edytuj cel';

    if (startMarker && goalMarker) {
      const startLatLng = startMarker.getLatLng();
      const endLatLng = goalMarker.getLatLng();
      const color = role === 'driver' ? driverColors[userId] : 'green';
      drawRouteOnMap(startLatLng, endLatLng, color, role);
    }
  }
};

  // ====== DANE FIREBASE ======
  function refreshUsers(snapshot){
  usersData = snapshot.val() || {};

 // ====== PASAÅ»EROWIE â€“ ZAWSZE OD NOWA ======
const passengers = Object.values(usersData)
  .filter(u => u.role === 'passenger' && typeof u.number === 'number')
  .sort((a, b) => a.number - b.number);

passengersOrder = passengers.map(p => p.number);

// kolory kierowcÃ³w
Object.entries(usersData).forEach(([id,u])=>{
  if(u.role==='driver' && !u.color) u.color=getRandomColor();
  if(u.role==='driver') driverColors[id]=u.color;
});

// natychmiastowe dopasowanie pasaÅ¼era
if(role==='passenger' && gridStart){
  matchedDrivers = Object.entries(usersData)
    .filter(([id,u])=> u.role==='driver' && u.start && u.end)
    // ðŸ”¹ filtrujemy kierowcÃ³w juÅ¼ zaakceptowanych przez innych pasaÅ¼erÃ³w
    .filter(([id,u]) => !Object.values(usersData).some(p => p.role==='passenger' && p.acceptedDriverId === id))
    .filter(([id,u])=>{
      const ps = gridStart;
      const dStart=parseCell(u.start);
      const dEnd=parseCell(u.end);
      const cells = (dStart.r===dEnd.r)
        ? Array.from({length:Math.abs(dEnd.c-dStart.c)+1},(_,i)=>({r:dStart.r,c:Math.min(dStart.c,dEnd.c)+i}))
        : Array.from({length:Math.abs(dEnd.r-dStart.r)+1},(_,i)=>({r:Math.min(dStart.r,dEnd.r)+i,c:dStart.c}));
      if(!cells.some(c => c.r === ps.r && c.c === ps.c)) return false;

const pe = gridEnd;
if(!pe) return false;

return isSameDirection(dStart, dEnd, ps, pe);
    }).map(([id,u])=>({id,...u}));
  selectedDriverIndex=0;
}



updateUsersTable();
updateGrid();
}


function updateUsersTable(){
  updateUsersHeader();
  usersTableBody.innerHTML='';

  const passengers = Object.values(usersData).filter(u=>u.role==='passenger');
  const drivers = Object.values(usersData).filter(u=>u.role==='driver');

  drivers.forEach(driver=>{
    const tr=document.createElement('tr');

tr.innerHTML = `
  <td>${driver.number}</td>
  <td style="background:${driver.color||''}"></td>
  ${passengersOrder.map(pNum=>{
    const p = passengers.find(x=>x.number===pNum);
    return `<td>${p && passengerOnDriverRoute(p,driver) ? 'O' : ''}</td>`;
  }).join('')}
`;


    usersTableBody.appendChild(tr);
  });
}


  db.ref("users").on('value',refreshUsers);

// ====== MAPA ======
const map = L.map('map');

L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
  attribution: 'Â© OpenStreetMap'
}).addTo(map);

// fallback (gdy GPS niedostÄ™pny)
map.setView([52.23, 21.01], 13);

// ====== CENTROWANIE MAPY NA UÅ»YTKOWNIKU ======
function centerMapOnUser() {
  if (!navigator.geolocation) return;

  navigator.geolocation.getCurrentPosition(pos => {
    const lat = pos.coords.latitude;
    const lng = pos.coords.longitude;

    map.setView([lat, lng], 14);
  });
}

map.on('click', e => {
  if (!goalEditMode) return;

  if (startMarker) {
    const startLatLng = startMarker.getLatLng();
    const endLatLng = { lat: e.latlng.lat, lng: e.latlng.lng };
    const color = role === 'driver' ? driverColors[userId] : 'green';
    drawRouteOnMap(startLatLng, endLatLng, color, role);

    if (!goalMarker) {
      goalMarker = L.marker([endLatLng.lat, endLatLng.lng]).addTo(map);
    } else {
      goalMarker.setLatLng([endLatLng.lat, endLatLng.lng]);
    }
  }
});

function drawRouteOnMap(startLatLng, endLatLng, color, role) {
  // jeÅ›li juÅ¼ istnieje, usuÅ„ poprzedniÄ… trasÄ™
  if (routeControl) {
    map.removeControl(routeControl);
  }

  // tworzymy trasÄ™
  routeControl = L.Routing.control({
    waypoints: [
      L.latLng(startLatLng.lat, startLatLng.lng),
      L.latLng(endLatLng.lat, endLatLng.lng)
    ],
    lineOptions: {
      styles: [{ color: color, weight: 5 }]
    },
    router: L.Routing.osrmv1({
      serviceUrl: 'https://router.project-osrm.org/route/v1',
      profile: role === 'driver' ? 'car' : 'foot'
    }),
    show: false,
    addWaypoints: false,
    routeWhileDragging: false,
    fitSelectedRoutes: true
  }).addTo(map);
}

// ====== START ======
initGrid();
centerMapOnUser();
</script>
</body>
</html>
