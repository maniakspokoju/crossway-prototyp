/* 6.1.9 pasaÅ¼er widzi swojÄ… trasÄ™, jednego kierowcy i wspÃ³lnÄ… trasÄ™ / kierowca widzi swojÄ… trasÄ™ / widaÄ‡ wszystkie markery. */

/*zamiana dla dziaÅ‚ania strony gdy OSMR nie odpowiada - zamiast > linii 265 dodaliÅ›my kod pod spodem  */


<!DOCTYPE html>
<html lang="pl">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no">

<title>Crossway Multi-user</title>
<link rel="stylesheet" href="https://unpkg.com/leaflet/dist/leaflet.css"/>
<style>
body {
    font-family: sans-serif;
    margin: 0;
    transition: background-color 0.3s ease;
    height: 100vh;
    display: flex;
    flex-direction: column;
}

/* ROLE BAR */
#roleBar {
  display: flex;
  width: 100%;
}
#roleBar button {
  width: 50%;
  height: 80px;
  font-size: 28px;
  border-radius: 0;
  cursor: pointer;
}
#driverBtn { background-color: #2f6fff; color: white; }
#passengerBtn { background-color: #2fbf6f; color: white; }

/* PANEL UÅ»YTKOWNIKA */
#driverDestinationDiv, #passengerControls {
  display: none;
  padding: 10px;
}
#driverDestinationDiv button, #passengerControls button {
  font-size: 24px;
  padding: 12px;
  margin: 5px 0;
  border-radius: 12px;
  cursor: pointer;
}
#driverDestinationDiv button:active, #passengerControls button:active {
  transform: scale(0.97);
}

/* MAPA */
#map {
  flex: 1;
}
</style>
</head>

<body>
<div style="display:flex; align-items:center; justify-content:space-between; margin:5px 10px;">
  																	<h1 style="margin:0;">Crossway â€“ 6.1.9</h1>
  <button id="resetBtn"
    style="font-size:16px; padding:6px 14px; border-radius:10px; cursor:pointer;">
    Reset
  </button>
</div>


<div id="roleBar">
  <button id="driverBtn">Driver</button>
  <button id="passengerBtn">Passenger</button>
</div>

<div id="driverDestinationDiv">
  <button id="saveDriverDestinationBtn">Edytuj cel</button>
</div>

<div id="passengerControls">
  <div style="display:flex; gap:10px; margin-bottom:10px;">
    <button id="modeBtn" style="flex:5;">Tryb A</button>
    <button id="acceptBtn" style="flex:8; background:#ff5722; color:white;">Akceptuj trasÄ™</button>
  </div>
  <div style="display:flex; gap:10px;">
    <button id="saveDestinationBtn" style="flex:1;">Edytuj cel</button>
    <button id="saveStartBtn" style="flex:1;">Edytuj start</button>
  </div>
</div>

<div id="driverBrowseControls" style="display:none; gap:10px; margin-top:10px;">
  <button id="prevDriverBtn" style="flex:1;">Cofnij</button>
  <button id="nextDriverBtn" style="flex:1;">Dalej</button>
</div>


<div id="map"></div>

<script src="https://www.gstatic.com/firebasejs/9.23.0/firebase-app-compat.js"></script>
<script src="https://www.gstatic.com/firebasejs/9.23.0/firebase-database-compat.js"></script>
<script src="https://unpkg.com/leaflet/dist/leaflet.js"></script>

<script>
/* ================= FIREBASE ================= */
firebase.initializeApp({
  apiKey: "AIzaSyBO8O-tNlduXs3VPr5UV8-A1MWesj1ptrc",
  databaseURL: "https://crossway-prototyp-default-rtdb.europe-west1.firebasedatabase.app/"
});
const db = firebase.database();

/* ================= GLOBAL ================= */
let currentUserId = null;
let currentRole = null;
let usersMarkers = {};
let driverLineOnMap = null; // linia kierowcy aktualnie wyÅ›wietlana dla pasaÅ¼era
let selectedPoint = null;
let editingDestination = false;
let editingStart = false;
let currentMode = "A";
let acceptLocked = false;
// let matchingDrivers = [];
// let currentDriverIndex = 0;


// ===== Funkcja pobierajÄ…ca kolejny numer uÅ¼ytkownika =====
async function getNextUserId() {
  const userCountRef = db.ref("session/userCount");
  const snapshot = await userCountRef.transaction(current => {
    return (current || 0) + 1; // jeÅ›li brak, ustaw 1, inaczej zwiÄ™ksz
  });
  return snapshot.snapshot.val(); // to bÄ™dzie numer kolejnego uÅ¼ytkownika
}


/* ================= BLOKADA GUZIKÃ“W W TRAKCIE EDYCJI ================= */
function togglePassengerButtons(disable, excludeIds = []) {
  const buttons = [
    "modeBtn",
    "acceptBtn",
    "saveDestinationBtn",
    "saveStartBtn",
    "nextDriverBtn",
    "prevDriverBtn"
  ];
  buttons.forEach(id => {
    if (excludeIds.includes(id)) return; // pomijamy wybrane guziki
    const btn = document.getElementById(id);
    if (btn) {
      btn.disabled = disable;
      btn.style.opacity = disable ? "0.4" : "1";
    }
  });
}

/* ================= MAPA ================= */
const map = L.map("map").setView([52.1, 19.9], 12);
L.tileLayer("https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png").addTo(map);
const overlapLine = L.polyline([], { color: "red", weight: 7 }).addTo(map);

/* ================= UTILS ================= */
function distanceMeters(a,b){
  const R=6371000,dLat=(b[0]-a[0])*Math.PI/180,dLng=(b[1]-a[1])*Math.PI/180,x=dLng*Math.cos((a[0]+b[0])/2*Math.PI/180);
  return Math.sqrt(dLat*dLat+x*x)*R;
}
const TOLERANCE_METERS = 40; // wiÄ™ksza tolerancja

function findClosestIndex(point, path){
  let min = Infinity, idx = -1;
  path.forEach((p, i) => {
    let pLat, pLng;
    if(Array.isArray(p)){
      [pLat, pLng] = p;
    } else {
      pLat = p.lat; pLng = p.lng;
    }
    const d = distanceMeters(point, [pLat, pLng]);
    if(d < min){ min = d; idx = i; }
  });
  // dodatkowy log dla debugowania
  // console.log("Closest distance:", min, "TOLERANCE_METERS:", TOLERANCE_METERS);
  return min <= TOLERANCE_METERS ? idx : -1;
}


function createIcon(userId, color){
  return L.divIcon({
    html:`<div style="font-size:26px;font-weight:bold;color:${color}">${userId}</div>`,
    className:"",
    iconSize:[30,30],
    iconAnchor:[15,15]
  });
}

async function route(a, b) {
  const url = `https://router.project-osrm.org/route/v1/driving/${a[1]},${a[0]};${b[1]},${b[0]}?overview=full&geometries=geojson`;

  try {
    const res = await fetch(url);
    if (!res.ok) throw new Error("OSRM response not ok");

    const data = await res.json();
    if (!data.routes || !data.routes[0]) throw new Error("No route");

    return data.routes[0].geometry.coordinates.map(c => [c[1], c[0]]);
  } catch (err) {
    console.warn("OSRM error:", err.message);
    return null;
  }
}


function randomColor(){
  return "#" + Math.floor(Math.random()*16777215).toString(16).padStart(6,"0");
}

/* ================= CREATE USER ================= */
async function createUser(role){
  currentUserId = await getNextUserId(); // nowy numer: 1,2,3...
  currentRole = role;

  const userColor = role === "driver" ? randomColor() : "green";

const startMarker = L.marker([0,0], {
  icon: createIcon(currentUserId, userColor)
}).addTo(map);

const endMarker = L.marker([0,0], {
  icon: createIcon(currentUserId, userColor)
}).addTo(map);

const line = L.polyline([], {
  color: userColor,
  weight: 5
}).addTo(map);

  usersMarkers[currentUserId] = {
  startMarker,
  endMarker,
  line,
  role,
  color: userColor,
  matchingDrivers: [],
  currentDriverIndex: 0
};



  navigator.geolocation.getCurrentPosition(p=>{
    const lat=p.coords.latitude, lng=p.coords.longitude;
    startMarker.setLatLng([lat,lng]);
    db.ref(`session/users/${currentUserId}`).set({
  role,
  color: userColor,
  currentLocation:{ latitude:lat, longitude:lng }
});
  });

  if(role==="driver") document.getElementById("driverDestinationDiv").style.display="block";
  if(role==="passenger") document.getElementById("passengerControls").style.display="block";

  // blokada przyciskÃ³w rÃ³l po wyborze
  document.getElementById("driverBtn").disabled=true;
  document.getElementById("driverBtn").style.opacity="0.4";
  document.getElementById("passengerBtn").disabled=true;
  document.getElementById("passengerBtn").style.opacity="0.4";
}

/* ================= MAP CLICK ================= */
map.on("click", function(e){
  if(!editingDestination && !editingStart) return;
  selectedPoint=[e.latlng.lat,e.latlng.lng];
  if(editingDestination) usersMarkers[currentUserId].endMarker.setLatLng(selectedPoint);
  if(editingStart) usersMarkers[currentUserId].startMarker.setLatLng(selectedPoint);
  drawUserRoute(currentUserId);
});

/* ================= DRAW ROUTE ================= */
async function drawUserRoute(userId){
  const user = usersMarkers[userId];
  if(!user) return;
  const start = user.startMarker.getLatLng();
  const end = user.endMarker.getLatLng();
const coords = await route(
  [start.lat, start.lng],
  [end.lat, end.lng]
);

//if (!coords) return; // ðŸ‘ˆ brak trasy â†’ nic nie rysujemy
if (!coords) {
  // fallback: prosta linia start â†’ koniec
  const user = usersMarkers[userId];
  const start = user.startMarker.getLatLng();
  const end = user.endMarker.getLatLng();
  user.line.setLatLngs([[start.lat, start.lng], [end.lat, end.lng]]);
  return;
}

user.line.setLatLngs(coords);

}

/* ================= SAVE BUTTONS ================= */
const saveDriverDestinationBtn = document.getElementById("saveDriverDestinationBtn");
saveDriverDestinationBtn.onclick = async ()=>{
  if(!editingDestination){editingDestination=true; saveDriverDestinationBtn.innerText="Zapisz cel"; return;}
  if(selectedPoint){
    usersMarkers[currentUserId].endMarker.setLatLng(selectedPoint);
    db.ref(`session/users/${currentUserId}/destination`).set({latitude:selectedPoint[0],longitude:selectedPoint[1]});
    drawUserRoute(currentUserId);
  }
  editingDestination=false;
  saveDriverDestinationBtn.innerText="Edytuj cel";
  selectedPoint=null;
};

// ================= SAVE DESTINATION =================
const saveDestinationBtn = document.getElementById("saveDestinationBtn");
saveDestinationBtn.onclick = async () => {
  if (!editingDestination) {
    editingDestination = true;
    saveDestinationBtn.innerText = "Zapisz cel";
    togglePassengerButtons(true, ["saveDestinationBtn"]); // blokujemy resztÄ™
    return;
  }

  if (selectedPoint) {
    usersMarkers[currentUserId].endMarker.setLatLng(selectedPoint);
    await db.ref(`session/users/${currentUserId}/destination`).set({
      latitude: selectedPoint[0],
      longitude: selectedPoint[1]
    });

    await drawUserRoute(currentUserId);

    if (currentRole === "passenger") {
      await findMatchingDrivers(currentUserId);
      showCurrentDriver();
    }
  }

  editingDestination = false;
  saveDestinationBtn.innerText = "Edytuj cel";
  togglePassengerButtons(false); // odblokowujemy wszystkie
  selectedPoint = null;
};

// ================= SAVE START =================
const saveStartBtn = document.getElementById("saveStartBtn");
saveStartBtn.onclick = async () => {
  if (!editingStart) {
    editingStart = true;
    saveStartBtn.innerText = "Zapisz start";
    // ðŸ”’ wszystkie pozostaÅ‚e guziki poza tym, ktÃ³rym klikamy
    togglePassengerButtons(true, ["saveStartBtn"]);
    return;
  }

  if (selectedPoint) {
    usersMarkers[currentUserId].startMarker.setLatLng(selectedPoint);
    await db.ref(`session/users/${currentUserId}/currentLocation`).set({
      latitude: selectedPoint[0],
      longitude: selectedPoint[1]
    });

    await drawUserRoute(currentUserId);

    if (currentRole === "passenger") {
      await findMatchingDrivers(currentUserId);
      showCurrentDriver();
    }
  }

  editingStart = false;
  saveStartBtn.innerText = "Edytuj start";
  togglePassengerButtons(false); // ðŸ”“ odblokowanie wszystkich
  selectedPoint = null;
};



/* ================= MODE ================= */
const modeBtn = document.getElementById("modeBtn");
modeBtn.onclick = ()=>{
  const newMode = currentMode==="A"?"B":"A";
  db.ref("session/mode").set(newMode);
};

// Funkcja do odÅ›wieÅ¼ania dopasowaÅ„ po zmianie trybu
function checkOverlaps(){
  if(currentRole==="passenger"){
    findMatchingDrivers(currentUserId).then(()=>showCurrentDriver());
  }
}

db.ref("session/mode").on("value", snap=>{
  if(snap.val()) currentMode = snap.val();
  modeBtn.innerText = "Tryb " + currentMode;
  checkOverlaps(); // teraz juÅ¼ istnieje, nie powoduje bÅ‚Ä™du
});


/* ================= OVERLAP ================= */
//const TOLERANCE_METERS = 150; // zwiÄ™kszona tolerancja, aby Å‚atwiej dopasowaÄ‡ trasÄ™

async function findMatchingDrivers(passengerId) {
  const passenger = usersMarkers[passengerId];
  if (!passenger) return;

  passenger.matchingDrivers = [];
  passenger.currentDriverIndex = 0;

  const pStart = passenger.startMarker.getLatLng();
  console.log("Passenger start:", pStart);

  for (let uid in usersMarkers) {
    const driver = usersMarkers[uid];
    if (driver.role !== "driver") continue;

    const path = driver.line.getLatLngs();
    if (!path || path.length === 0) continue;

    // 1ï¸âƒ£ start pasaÅ¼era na trasie kierowcy
    const startIdx = findClosestIndex(
      [pStart.lat, pStart.lng],
      path
    );
    if (startIdx === -1) continue;

// 2ï¸âƒ£ szukamy OSTATNIEGO przeciÄ™cia tras (pierwsze od koÅ„ca)
let endIdx = -1;
const passengerPath = passenger.line.getLatLngs();

// Wklejamy sprawdzenie:
if (!passengerPath || passengerPath.length === 0) continue;

for (let i = path.length - 1; i > startIdx; i--) {
  const p = path[i];
  const idxOnPassenger = findClosestIndex(
    [p.lat, p.lng],
    passengerPath
  );

  if (idxOnPassenger !== -1) {
    endIdx = i;
    break; // PIERWSZE od tyÅ‚u = OSTATNIE logicznie
  }
}

// jeÅ›li brak drugiego przeciÄ™cia â†’ NIE Tryb A
if (endIdx === -1) continue;

passenger.matchingDrivers.push({
  driverId: uid,
  fromIndex: startIdx,
  toIndex: endIdx
});
  }

  console.log("Matching drivers (MODE A):", passenger.matchingDrivers);

  if (passenger.matchingDrivers.length > 0) {
    document.getElementById("driverBrowseControls").style.display = "flex";
  } else {
    overlapLine.setLatLngs([]);
    document.getElementById("driverBrowseControls").style.display = "none";
  }
}



// WyÅ›wietla trasÄ™ aktualnego dopasowanego kierowcy
function showCurrentDriver() {
if (currentRole !== "passenger") return; // tylko pasaÅ¼er wykonuje tÄ™ funkcjÄ™
  const passenger = usersMarkers[currentUserId];
  if (!passenger || passenger.matchingDrivers.length === 0) {
    overlapLine.setLatLngs([]);
    if (driverLineOnMap) {
      map.removeLayer(driverLineOnMap);
      driverLineOnMap = null;
    }
    return;
  }

  const match = passenger.matchingDrivers[passenger.currentDriverIndex];
  const driver = usersMarkers[match.driverId];
  if (!driver) return;

  const driverPath = driver.line.getLatLngs();
  const overlapPath = driverPath.slice(match.fromIndex, match.toIndex + 1);

  // 1ï¸âƒ£ zawsze aktualizujemy trasÄ™ wspÃ³lnÄ…
  overlapLine.setLatLngs(overlapPath);
  overlapLine.bringToFront();

  // 2ï¸âƒ£ usuÅ„ starÄ… liniÄ™ kierowcy, jeÅ›li byÅ‚a
  if (driverLineOnMap) {
    map.removeLayer(driverLineOnMap);
    driverLineOnMap = null;
  }

  // 3ï¸âƒ£ dodaj nowÄ… liniÄ™ kierowcy
  driverLineOnMap = L.polyline(driverPath, {
    color: driver.color,
    weight: 5,
    opacity: 0.7
  }).addTo(map);
}




// Guziki do przeÅ‚Ä…czania miÄ™dzy kierowcami
document.getElementById("nextDriverBtn").onclick = () => {
  const passenger = usersMarkers[currentUserId];
  if (!passenger || passenger.matchingDrivers.length === 0) return;

  // usuÅ„ starÄ… liniÄ™ kierowcy z mapy
  if (driverLineOnMap) {
    map.removeLayer(driverLineOnMap);
    driverLineOnMap = null;
  }

  passenger.currentDriverIndex =
    (passenger.currentDriverIndex + 1) % passenger.matchingDrivers.length;

  showCurrentDriver();
};

document.getElementById("prevDriverBtn").onclick = () => {
  const passenger = usersMarkers[currentUserId];
  if (!passenger || passenger.matchingDrivers.length === 0) return;

  if (driverLineOnMap) {
    map.removeLayer(driverLineOnMap);
    driverLineOnMap = null;
  }

  passenger.currentDriverIndex =
    (passenger.currentDriverIndex - 1 + passenger.matchingDrivers.length) %
    passenger.matchingDrivers.length;

  showCurrentDriver();
};







/* ================= EVENTY ROLE ================= */
document.getElementById("driverBtn").onclick = () => {
  if (driverLineOnMap) { 
    map.removeLayer(driverLineOnMap); 
    driverLineOnMap = null; 
  }
  document.body.style.backgroundColor = "#2f6fff"; 
  createUser("driver");
};

document.getElementById("passengerBtn").onclick = () => {
  if (driverLineOnMap) { 
    map.removeLayer(driverLineOnMap); 
    driverLineOnMap = null; 
  }
  document.body.style.backgroundColor = "#2fbf6f"; 
  createUser("passenger");
};


/* ================= SYNC USERS ================= */
/* ================= SYNC USERS â€“ peÅ‚na synchronizacja ================= */
db.ref("session/users").on("value", async snap => {
  const allUsers = snap.val() || {};

  for (let uid in allUsers) {
    const data = allUsers[uid];

    // jeÅ›li uÅ¼ytkownik juÅ¼ istnieje w usersMarkers, aktualizujemy markery i trasÄ™
    if (usersMarkers[uid]) {
      const user = usersMarkers[uid];

      // aktualizacja startu
      if (data.currentLocation) {
        user.startMarker.setLatLng([data.currentLocation.latitude, data.currentLocation.longitude]);
      }

      // aktualizacja celu
      if (data.destination) {
        user.endMarker.setLatLng([data.destination.latitude, data.destination.longitude]);
      }

      // aktualizacja linii
      if (data.currentLocation && data.destination) {
        await drawUserRoute(uid);
      }

      continue; // idziemy do nastÄ™pnego uid
    }

    // jeÅ›li uÅ¼ytkownik jeszcze nie istnieje â†’ tworzymy
    const role = data.role;
    const color = data.color || (role === "driver" ? randomColor() : "green");

    const startLat = data.currentLocation?.latitude || 0;
    const startLng = data.currentLocation?.longitude || 0;

    const endLat = data.destination?.latitude || startLat;
    const endLng = data.destination?.longitude || startLng;

    const startMarker = L.marker([startLat, startLng], { icon: createIcon(uid, color) }).addTo(map);
    const endMarker = L.marker([endLat, endLng], { icon: createIcon(uid, color) }).addTo(map);
const line = L.polyline([], { color, weight: 5 });

// Kierowca widzi tylko swojÄ… liniÄ™
if (currentRole === "driver" && uid === currentUserId) {
  line.addTo(map);
}

// PasaÅ¼er nie zmienia logiki (widzi wszystko zgodnie z wczeÅ›niejszymi zmianami)




    usersMarkers[uid] = { startMarker, endMarker, line, role, color };

    // rysowanie trasy jeÅ›li sÄ… dane start + cel
    if (data.currentLocation && data.destination) {
      await drawUserRoute(uid);
    }
  }

  // jeÅ›li jesteÅ›my pasaÅ¼erem â†’ sprawdzamy dopasowania
  if (currentRole === "passenger" && currentUserId) {
    await findMatchingDrivers(currentUserId);
    showCurrentDriver();
  }
});

/* ================= RESET ================= */
document.getElementById("resetBtn").onclick = async () => {
  if (!confirm("Czy na pewno zresetowaÄ‡ caÅ‚Ä… sesjÄ™?")) return;

  // 1. Firebase â€“ czyÅ›cimy WSZYSTKO
  await db.ref("session").set(null);

  // 2. Mapa â€“ usuwamy markery i linie
  for (let uid in usersMarkers) {
    const u = usersMarkers[uid];
    map.removeLayer(u.startMarker);
    map.removeLayer(u.endMarker);
    map.removeLayer(u.line);
  }
  overlapLine.setLatLngs([]);

if (driverLineOnMap) {
  map.removeLayer(driverLineOnMap);
  driverLineOnMap = null;
}


  // 3. Reset lokalnego stanu
  usersMarkers = {};
  currentUserId = null;
  currentRole = null;
  selectedPoint = null;
  editingDestination = false;
  editingStart = false;
  currentMode = "A";
  acceptLocked = false;

  // 4. UI
  document.body.style.backgroundColor = "";
  document.getElementById("driverDestinationDiv").style.display = "none";
  document.getElementById("passengerControls").style.display = "none";
  document.getElementById("driverBrowseControls").style.display = "none";

  document.getElementById("driverBtn").disabled = false;
  document.getElementById("driverBtn").style.opacity = "1";
  document.getElementById("passengerBtn").disabled = false;
  document.getElementById("passengerBtn").style.opacity = "1";

  document.getElementById("modeBtn").innerText = "Tryb A";

  alert("Sesja zostaÅ‚a zresetowana.");
};

</script>

</body>
</html>
